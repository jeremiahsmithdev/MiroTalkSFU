export type RelationOneToOne<E extends {
    id: string;
}, T> = {
    [x in E['id']]: T;
};
export type RelationOneToMany<E1 extends {
    id: string;
}, E2 extends {
    id: string;
}> = {
    [x in E1['id']]: Array<E2['id']>;
};
export type RelationOneToManyUnique<E1 extends {
    id: string;
}, E2 extends {
    id: string;
}> = {
    [x in E1['id']]: Set<E2['id']>;
};
export type IDMappedObjects<E extends {
    id: string;
}> = RelationOneToOne<E, E>;
export type IDMappedCollection<T extends {
    id: string;
}> = {
    data: IDMappedObjects<T>;
    order: Array<T['id']>;
    errors?: RelationOneToOne<T, Error>;
    warnings?: RelationOneToOne<T, {
        [Key in keyof T]?: string;
    }>;
};
export type DeepPartial<T> = {
    [K in keyof T]?: (T[K] extends Set<any> ? T[K] : T[K] extends Map<any, any> ? T[K] : T[K] extends object ? DeepPartial<T[K]> : T[K] extends object | undefined ? DeepPartial<T[K]> : T[K]);
};
export type ValueOf<T> = T[keyof T];
/**
 * Based on https://stackoverflow.com/a/49725198
 */
export type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;
}[Keys];
export type Intersection<T1, T2> = Omit<Omit<T1 & T2, keyof (Omit<T1, keyof (T2)>)>, keyof (Omit<T2, keyof (T1)>)>;
/** https://stackoverflow.com/a/66605669 */
type Only<T, U> = {
    [P in keyof T]: T[P];
} & {
    [P in keyof U]?: never;
};
export type Either<T, U> = Only<T, U> | Only<U, T>;
export type PartialExcept<T extends Record<string, unknown>, TKeysNotPartial extends keyof T> = Partial<T> & Pick<T, TKeysNotPartial>;
export declare function isArrayOf<T>(v: unknown, check: (e: unknown) => boolean): v is T[];
export declare function isStringArray(v: unknown): v is string[];
export declare function isRecordOf<T>(v: unknown, check: (e: unknown) => boolean): v is Record<string, T>;
export declare const collectionFromArray: <T extends {
    id: string;
}>(arr?: T[]) => IDMappedCollection<T>;
export declare const collectionToArray: <T extends {
    id: string;
}>({ data, order }: IDMappedCollection<T>) => T[];
export declare const collectionReplaceItem: <T extends {
    id: string;
}>(collection: IDMappedCollection<T>, ...items: T[]) => {
    data: IDMappedObjects<T>;
    order: T["id"][];
    errors?: RelationOneToOne<T, Error> | undefined;
    warnings?: RelationOneToOne<T, { [Key in keyof T]?: string | undefined; }> | undefined;
};
export declare const collectionAddItem: <T extends {
    id: string;
}>(collection: IDMappedCollection<T>, ...items: T[]) => {
    order: string[];
    data: IDMappedObjects<T>;
    errors?: RelationOneToOne<T, Error> | undefined;
    warnings?: RelationOneToOne<T, { [Key in keyof T]?: string | undefined; }> | undefined;
};
export declare const collectionRemoveItem: <T extends {
    id: string;
}>(collection: IDMappedCollection<T>, item: T) => {
    data: IDMappedObjects<T>;
    order: T["id"][];
    errors?: RelationOneToOne<T, Error> | undefined;
    warnings?: RelationOneToOne<T, { [Key in keyof T]?: string | undefined; }> | undefined;
};
export declare const idMappedObjectsFromArr: <T extends {
    id: string;
}>(items: T[], current?: IDMappedObjects<T>) => IDMappedObjects<T>;
export {};
